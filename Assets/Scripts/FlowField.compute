// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Advect

Texture3D<unorm float4> _NormalDirections;
Texture3D<float> _HeightMagnitudes;

RWTexture3D<unorm float4> _NormalDirectionsRW;
RWTexture3D<float> _HeightMagnitudesRW;

float _decay;
float _deltaTime;
float _Time;
float _TimeScale;

float3 _SpherePos;
float3 _SphereVelocity;
float _SphereRadius;

float4 _NormalDirections_TexelSize;
SamplerState SmpClampPoint;

#define TSAMP SmpClampPoint
#define FLOW_SAMPLE(texture3D, uv) texture3D.SampleLevel(TSAMP, uv, 0.0, 0)
#define FLOW_SAMPLE_DIRECTION(uv) FLOW_SAMPLE(_NormalDirections, uv)
#define FLOW_SAMPLE_MAGNITUDE(uv) FLOW_SAMPLE(_HeightMagnitudes, uv)

float3 _UV_Offset;
float3 BOUNDS_MIN, BOUNDS_EXTENTS, BOUNDS_SIZE;
uint WIDTH, HEIGHT, DEPTH;
float3 TEXEL_SIZE;
uint3 TEX_DIMENSIONS;

uint3 GetCoord(int index) {
    uint z = index % TEX_DIMENSIONS.z;
    uint y = (index / TEX_DIMENSIONS.z) % TEX_DIMENSIONS.y;
    uint x = index / (TEX_DIMENSIONS.y * TEX_DIMENSIONS.z);
    return uint3(x, y, z);
}

float4 GetIndexUV(int index) {
    uint3 coord = GetCoord(index);
    return float4(
      coord.x * TEXEL_SIZE.x,
      coord.y * TEXEL_SIZE.y,
      coord.z * TEXEL_SIZE.z,
      1
    );
}

float4 GetWorldUV(int index) {
    float3 uv = GetIndexUV(index).xyz;
    // Moves UV into center of texel in world space
    return float4(uv + TEXEL_SIZE * 0.5 + _UV_Offset, 1);
}

float3 GetWorldPosition(int index) {
    float3 uv = GetWorldUV(index).xyz;
    return BOUNDS_MIN + float3(
         uv.x * BOUNDS_SIZE.x,
         uv.y * BOUNDS_SIZE.y,
         uv.z * BOUNDS_SIZE.z
    );
}

float3 invLerp(float3 from, float3 to, float3 value) {
    return (value - from) / (to - from);
}

float3 GetTexUVFromWorldPosition(float3 pos) {
    float3 WORLD_TEXEL_SIZE = float3(
        BOUNDS_SIZE.x / TEX_DIMENSIONS.x,
        BOUNDS_SIZE.y / TEX_DIMENSIONS.y,
        BOUNDS_SIZE.z / TEX_DIMENSIONS.z
    );
    float3 offsetToCenter = WORLD_TEXEL_SIZE * 0.5;
    float3 fromTexInWorldPos = BOUNDS_MIN + offsetToCenter;
    float3 toTexInWorldPos = BOUNDS_MIN + BOUNDS_SIZE - offsetToCenter;
    return invLerp(fromTexInWorldPos, toTexInWorldPos, pos);
}


float applyDecay(float value)
{
    return max(0, value + _decay * _deltaTime);
}

float3 decodeDirection(float4 direction)
{
    return direction.rgb * 2 - 1;
}

float4 encodeDirection(float4 direction)
{
    return (direction + 1) * 0.5;
}

float4 encodeDirection(float x, float y, float z)
{
    return encodeDirection(float4(x, y, z, 1));
}

//[numthreads(64,1,1)]
//void UpdateTransforms (uint3 id : SV_DispatchThreadID)
//{
//    float3 pos = GetWorldPosition(id.x);
//    uint3 coord = GetCoord(id.x);
//    float currentMagnitude = _HeightMagnitudes[coord];
//    _HeightMagnitudesRW[coord] = applyDecay(currentMagnitude);
//
//    float t = _Time * _TimeScale;
//    
//    if (distance(pos, _SpherePos) < _SphereRadius) {
//        _HeightMagnitudesRW[coord] = 1;
//        _NormalDirectionsRW[coord] = encodeDirection(normalize(_SphereVelocity));
//    }
//}

// Advect step
[numthreads(64, 1, 1)]
void Advect(uint3 id : SV_DispatchThreadID)
{
    uint3 coord = GetCoord(id.x);
    float3 pos = GetWorldPosition(id.x);
    float3 velocity = _HeightMagnitudes[coord] * decodeDirection(_NormalDirections[coord]);
    float3 backstepPos = pos - velocity * _deltaTime;
    float3 backstepUV = GetTexUVFromWorldPosition(backstepPos);

    _HeightMagnitudesRW[coord] = FLOW_SAMPLE_MAGNITUDE(backstepUV);
    _NormalDirectionsRW[coord] = FLOW_SAMPLE_DIRECTION(backstepUV);
}
