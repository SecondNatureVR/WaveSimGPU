// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel UpdateTransforms


RWTexture3D<snorm float3> _NormalDirections;
RWTexture3D<float> _HeightMagnitudes;

float _decay;
float _deltaTime;

float3 _SpherePos;
float3 _SphereVelocity;
float _SphereRadius;

float4 _NormalDirections_TexelSize;
SamplerState SmpClampPoint;

#define TSAMP SmpClampPoint
#define FLOW_SAMPLE(texture3D, uv) texture3D.SampleLevel(TSAMP, uv, 0.0, 0)
#define FLOW_SAMPLE_DIRECTION(uv) FLOW_SAMPLE(_NormalDirections, uv)
#define FLOW_SAMPLE_MAGNITUDE(uv) FLOW_SAMPLE(_HeightMagnitudes, uv)

float3 _UV_Offset;
float3 BOUNDS_MIN, BOUNDS_EXTENTS, BOUNDS_SIZE;
uint WIDTH, HEIGHT, DEPTH;
float3 TEXEL_SIZE;
uint3 TEX_DIMENSIONS;

uint3 GetCoord(int index) {
    uint z = index % TEX_DIMENSIONS.z;
    uint y = (index / TEX_DIMENSIONS.z) % TEX_DIMENSIONS.y;
    uint x = index / (TEX_DIMENSIONS.y * TEX_DIMENSIONS.z);
    return uint3(x, y, z);
}

float4 GetIndexUV(int index) {
    uint3 coord = GetCoord(index);
    return float4(
      coord.x * TEXEL_SIZE.x,
      coord.y * TEXEL_SIZE.y,
      coord.z * TEXEL_SIZE.z,
      1
    );
}

float4 GetWorldUV(int index) {
    float3 uv = GetIndexUV(index).xyz;
    // Moves UV into center of texel in world space
    return float4(uv + TEXEL_SIZE * 0.5 + _UV_Offset, 1);
}

float3 GetWorldPosition(int index) {
    float3 uv = GetWorldUV(index).xyz;
    return BOUNDS_MIN + float3(
         uv.x * BOUNDS_SIZE.x,
         uv.y * BOUNDS_SIZE.y,
         uv.z * BOUNDS_SIZE.z
    );
}

[numthreads(64,1,1)]
void UpdateTransforms (uint3 id : SV_DispatchThreadID)
{
    uint3 coord = GetCoord(id.x);
    float3 uv = GetWorldUV(id.x);
    float m = FLOW_SAMPLE_MAGNITUDE(uv);
    flowVectors[id.x].magnitude = max(0, m + _decay * _deltaTime);

    float3 pos = flow.transform._m03_m13_m23;
    if (distance(pos, _SpherePos) < _SphereRadius) {
        if (length(_SphereVelocity) > m)
        {
            flowVectors[id.x].magnitude = clamp(0.2, 1, length(_SphereVelocity));
            float4x4 tmat = flowVectors[id.x].transform;

            // set new rotation toward velocity
            // https://math.stackexchange.com/questions/180418/calculate-rotation-matrix-to-align-vector-a-to-vector-b-in-3d
            float3x3 rmat = 0.0;
            rmat._m00_m11_m22 = float3(1, 1, 1);

            float3 a = float3(0, 1, 0);
            float3 b = normalize(_SphereVelocity);
            float3 v = cross(a, b);
            float c = dot(a, b);
            float3x3 ssc = {
                 0, -v.z,  v.y,
               v.z,    0, -v.x,
              -v.y,  v.x,    0,
            };
            float3x3 term2 = mul(ssc, ssc) * rcp(1 + c);
            rmat += ssc + term2;

            flowVectors[id.x].transform._m00_m01_m02 = rmat._m00_m01_m02;
            flowVectors[id.x].transform._m10_m11_m12 = rmat._m10_m11_m12;
            flowVectors[id.x].transform._m20_m21_m22 = rmat._m20_m21_m22;
        }
    }
}
